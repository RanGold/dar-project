package IC.Parser;

import IC.AST.*;
import IC.DataTypes;
import java_cup.runtime.*;
import java.util.List;
import java.util.LinkedList;

////////////////////////////////////////////
// Symbol list (terminals and non-terminals)

terminal ASSIGN,BOOLEAN,BREAK,CLASS,CONTINUE,DIVIDE,DOT,EQUAL,EXTENDS,ELSE,FALSE,COMMA,GT,GTE,IF,INT,LAND,LB,LP,LCBR,LENGTH,NEW,LNEG,LOR,LT,LTE,MINUS,MOD,MULTIPLY,NEQUAL,NULL,PLUS,RB,RCBR,RETURN,RP,SEMI,STATIC,STRING,THIS,TRUE,VOID,WHILE;
terminal String CLASS_ID;
terminal String ID;
terminal Integer INTEGER;
terminal String QUOTE;

non terminal ICClass libic;
non terminal LibraryMethod libmethod;
non terminal List<Method> libmethod_list;
non terminal Formal formal;
non terminal List<Formal> formal_list;
non terminal Type type;

//////////////////////////
// Precedence declarations

precedence left LP, RP, LB, RB;

//////////////
// The grammar

libic ::= CLASS CLASS_ID:class_id LCBR libmethod_list:lm_list RCBR
			{: 	
				if (class_id.compareTo("Library") != 0) throw new SyntaxError("Illegal library class name",class_idleft);
				RESULT = new ICClass(class_idleft,class_id,new LinkedList<Field>(),lm_list); 
			:};

type ::= INT:integ
			{: RESULT = new PrimitiveType(integleft, DataTypes.INT); :}
		| STRING:str
			{: RESULT = new PrimitiveType(strleft, DataTypes.STRING); :}
		| BOOLEAN:bool
			{: RESULT = new PrimitiveType(boolleft, DataTypes.BOOLEAN); :}
		| CLASS_ID:class_id
			{: RESULT = new UserType(class_idleft, class_id); :}
		| type:t LB RB
			{:	
				t.incrementDimension();
				RESULT = t; 
			:};
			
formal ::= type:t ID:id
			{:
				RESULT = new Formal(t,id);
			:};

formal_list ::= formal:f
			{: 	
				RESULT = new LinkedList<Formal>(); 
				RESULT.add(f);
			:}
			| formal_list:fl COMMA formal:f
			{:	
				fl.add(f);
				RESULT = fl;
			:};

libmethod ::= STATIC VOID ID:id LP RP SEMI
			{:
				RESULT=new LibraryMethod(new PrimitiveType(idleft,DataTypes.VOID),id,new LinkedList<Formal>());
			:}
			| STATIC type:t ID:id LP RP SEMI
			{:
				RESULT=new LibraryMethod(t,id,new LinkedList<Formal>());
			:}	
			| STATIC VOID ID:id LP formal_list:fl RP SEMI
			{:
				RESULT=new LibraryMethod(new PrimitiveType(idleft,DataTypes.VOID),id,fl);
			:}
			| STATIC type:t ID:id LP formal_list:fl RP SEMI
			{:
				RESULT=new LibraryMethod(t,id,fl);
			:};

libmethod_list ::= libmethod:lm
			{: 	
				RESULT = new LinkedList<Method>(); 
				RESULT.add(lm);
			:}
			| libmethod_list:lml libmethod:lm
			{:	
				lml.add(lm);
				RESULT = lml;
			:};